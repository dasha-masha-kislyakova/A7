// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assignments.sql

package logisticq

import (
	"context"
	"database/sql"
	"time"
)

const insertAssignment = `-- name: InsertAssignment :exec
INSERT INTO assignments(shipment_id,application_external_id,weight_kg,volume_m3,created_at,pickup_point_external_id,dropoff_point_external_id)
VALUES ($1,$2,$3,$4,now(),$5,$6)
`

type InsertAssignmentParams struct {
	ShipmentID             int64
	ApplicationExternalID  int64
	WeightKg               float64
	VolumeM3               float64
	PickupPointExternalID  sql.NullInt64
	DropoffPointExternalID sql.NullInt64
}

func (q *Queries) InsertAssignment(ctx context.Context, arg InsertAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, insertAssignment,
		arg.ShipmentID,
		arg.ApplicationExternalID,
		arg.WeightKg,
		arg.VolumeM3,
		arg.PickupPointExternalID,
		arg.DropoffPointExternalID,
	)
	return err
}

const listAssignments = `-- name: ListAssignments :many
SELECT id,shipment_id,application_external_id,weight_kg,volume_m3,created_at FROM assignments ORDER BY id DESC
`

type ListAssignmentsRow struct {
	ID                    int64
	ShipmentID            int64
	ApplicationExternalID int64
	WeightKg              float64
	VolumeM3              float64
	CreatedAt             time.Time
}

func (q *Queries) ListAssignments(ctx context.Context) ([]ListAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAssignments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssignmentsRow
	for rows.Next() {
		var i ListAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ShipmentID,
			&i.ApplicationExternalID,
			&i.WeightKg,
			&i.VolumeM3,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumLoadByShipment = `-- name: SumLoadByShipment :one
SELECT COALESCE(SUM(weight_kg),0), COALESCE(SUM(volume_m3),0) FROM assignments WHERE shipment_id=$1
`

type SumLoadByShipmentRow struct {
	Coalesce   interface{}
	Coalesce_2 interface{}
}

func (q *Queries) SumLoadByShipment(ctx context.Context, shipmentID int64) (SumLoadByShipmentRow, error) {
	row := q.db.QueryRowContext(ctx, sumLoadByShipment, shipmentID)
	var i SumLoadByShipmentRow
	err := row.Scan(&i.Coalesce, &i.Coalesce_2)
	return i, err
}
